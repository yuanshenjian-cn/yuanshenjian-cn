---
title: OpenCode 基础使用：提升编程效率的技巧
date: '2026-02-07'
tags:
  - 软件开发
  - AI编程
  - 效率工具
  - OpenCode
published: true
brief: >-
  掌握 OpenCode 的一些基础使用技巧，从初级自然语言提问到高级自定义配置，通过实战案例学习如何用 AI Coding Agent 提升编码效率。
---

## 内置工具清单

OpenCode 提供了丰富的内置工具集，让 AI 能够直接操作代码库。这些工具是 OpenCode 强大能力的基石，了解它们的工作原理和配置方式，能让你更好地控制 AI 的行为。

| 工具 | 功能 | 权限选项 | 使用场景 |
|------|------|----------|----------|
| **bash** | 执行 shell 命令 | allow/deny/ask | 运行测试、安装依赖、执行构建脚本 |
| **read** | 读取文件内容 | allow | 分析代码、理解项目结构 |
| **write** | 创建新文件 | allow/ask | 生成代码、创建配置文件 |
| **edit** | 修改文件内容 | allow/ask | 重构代码、修复 Bug |
| **patch** | 应用代码补丁 | allow/ask | 批量修改、跨文件重构 |
| **grep** | 搜索文件内容 | allow | 查找函数定义、定位问题代码 |
| **glob** | 列出匹配文件 | allow | 查找特定类型文件 |
| **list** | 列出目录内容 | allow | 浏览项目结构 |
| **webfetch** | 抓取网页内容 | allow | 获取 API 文档、技术文章 |
| **websearch** | 网络搜索 | allow（需 `OPENCODE_ENABLE_EXA=1`）| 查找解决方案、技术资料 |
| **skill** | 加载 SKILL.md 技能文件 | allow | 扩展 AI 能力、自定义工作流 |
| **todowrite** | 创建/更新任务清单 | allow | 项目管理、任务跟踪 |
| **todoread** | 读取任务清单 | allow | 查看任务进度 |
| **question** | 向用户提问 | allow | 获取用户输入、确认操作 |


## 高级 Slash 命令

除了基础命令，OpenCode 还提供了许多高级命令，帮助你更高效地使用。

| 命令 | 功能 | 使用场景 |
|------|------|----------|
| `/theme` | 切换主题 | 调整界面外观 |
| `/export` | 导出对话为 Markdown | 整理和分享 |
| `/compact` | 压缩当前会话 | 总结上下文，节省 Token |
| `/share` | 分享当前会话 | 与团队成员合作、展示项目 |
| `/unshare` | 取消分享当前会话 | 退出与团队成员的合作会话 |

## 使用技巧

### 快速上手

刚开始用 OpenCode 的时候，我也是从最简单的对话开始的。其实不需要学什么特定语法，就像和同事聊天一样说出你的需求就行。

**自然语言提问：别把 AI 想得太复杂**

记得有一次，我需要快速搭一个后台登录页面，传统做法得先想用什么框架、怎么布局、样式怎么写。但在 OpenCode 里，我直接说：

```
当前目录下创建一个登录页面，包含用户名和密码输入框
```

就这么一句话，AI 自动给我生成了 HTML 结构、CSS 样式，甚至连表单验证的逻辑都写好了。从想法到能跑起来的页面，也就几分钟的事。

这种方法特别适合那些"有个大概想法但不想纠结细节"的场景，比如快速原型、临时页面、或者验证一个想法。

**解释代码：终于不用猜同事写的代码了**

相信你一定遇到过这种情况：接手一个老项目，看到某个函数不知道它是干嘛的，注释也没有，命名还特模糊。以前得打断点、看调用链，折腾半天。

现在我直接用：

```
@utils.js 中的这个函数是做什么的？
```

AI 不仅告诉我这个函数的功能，还会分析参数含义、返回值是什么、在哪里被调用过。就像有个资深工程师在旁边给你讲解一样。

这个功能在接手遗留代码、阅读开源库、或者自己写的代码过久了忘了逻辑的时候特别有用。

**快速修复：让 AI 当你的 Debugger**

有一次我跑 Python 脚本报错，错误信息一大串，Google 了半天没找到对症的解决方案。后来试试让 OpenCode 看看：

```
修复 @app.py 中的语法错误
```

结果 AI 不仅定位到了问题（原来是个缩进问题），还告诉我为什么会这样、怎么避免下次再犯。这种"边修边学"的体验挺棒的，特别适合那些你觉得"这个问题肯定有人遇到过"的情况。

**查看和切换模型：找到最适合你的"脑袋"**

```
/models
```

不同模型擅长的领域不一样。比如 Claude 写代码比较稳，Claude 分析需求比较强，Kimi 的长文本处理更好。有时候一个模型给的方案不满意，切换另一个试试，经常会有惊喜。当你觉得 AI 的回答"差点意思"的时候，换个模型可能就能得到更好的答案。

**撤销操作：AI 改错了也能一键回退**

```
/undo
```

这个功能需要在 Git 管理下才能用。说实话，刚开始我还有点担心 AI 会不会乱改代码，有了撤销功能就放心多了。就算 AI 理解错了我的意思，一键就能回到之前的状态，不用担心搞砸项目。有了这个功能，你就可以放心大胆地让 AI 尝试各种修改，不用担心改坏了回不来。

### 提升效率

用了 OpenCode 一段时间后，我开始追求更高效的用法。以下这些技巧帮我省了不少时间。

**Plan 模式：复杂任务别急着动手**

有一次我需要给用户模块加一个"回收站"功能，涉及前端页面、后端接口、数据库表结构好几个地方。如果直接让 AI 写代码，它可能会漏掉某些边界情况。

后来我学聪明了，先用 Plan 模式：

1. 按 `Tab` 切换到 Plan 模式
2. 把需求拆成小块：

```
为用户模块添加删除功能：
1. 软删除标记（数据库层面加个 deleted_at 字段）
2. 回收站页面（展示已删除用户，支持搜索和筛选）
3. 恢复和永久删除选项（按钮和相关接口）
```

3. AI 会生成一个详细的执行计划，包括要改哪些文件、每个文件做什么修改
4. 我检查一遍，发现 AI 还提醒我别忘了给回收站加权限控制，这个我差点漏了
5. 确认没问题后，`Tab` 切回 Build 模式执行

这种先规划再执行的方式，在需求比较复杂、涉及多个文件或模块时特别靠谱，比盲目开干强多了。

**批量文件操作：告别机械重复劳动**

之前公司有个老 Java 项目，里面大量用了 `var` 声明变量，代码审查时要求改成显式类型。几十个文件，手动改能改到天荒地老。

我就让 OpenCode 帮忙：

```
将所有 .java 文件中的 var 替换为对应的类型
```

AI 先用 grep 找出所有用到 var 的地方，分析上下文推断具体类型，然后批量替换。整个过程全自动，我就喝口茶的功夫就改完了。这种"机械重复但需要一定判断力"的批量操作，AI 特别擅长。

**代码审查：多一双眼睛看代码**

我自己写的代码，有时候会有盲点，看不出问题。现在提交前会让 OpenCode 过一遍：

```
审查 @src/components 目录下的代码，找出潜在问题
```

AI 会从代码质量、安全性、性能等角度分析。比如有一次它提醒我一个 API 接口没做参数校验，可能会被 SQL 注入，这个我当时真没注意到。作为代码提交前的最后一道防线，能发现一些自己容易忽略的问题。

**添加图片参考：直接把设计图"喂"给 AI**

和产品经理开会，她给我一张设计稿截图。以前我得一边看图一边写 CSS，不断调整对位。现在更简单了：

直接把图片拖拽到终端，然后说：

```
按照这个设计图实现页面布局
[图片已添加]
```

AI 能理解图片中的布局结构，生成对应的 HTML 和 CSS。当然这个需要模型支持视觉能力，比如 Kimi for Coding 的多模态模型 K2.5 就挺好用的。有了这个功能，根据设计稿还原页面的时候特别省事，尤其是那种布局复杂的页面。

**我的实践案例**

我自己的简历页面就是这么做的——直接把 PDF 简历截图丢给 AI，让它参考样式生成在线版本。半小时就搞定了，现在可以直接维护在线 [简历](/resume) 了。

**会话管理：别把所有对话混在一起**

```
/sessions    # 查看所有会话
/new         # 开始新会话
/compact     # 压缩当前会话（总结上下文）
```

刚开始我总是用一个会话处理所有任务，结果上下文越来越长，AI 的回复质量也慢慢下降。后来我学会了按任务开新会话，一个会话专注解决一个问题。`/compact` 也挺有用，当上下文太长时压缩一下，AI 会把之前的内容总结成关键要点，节省 token 的同时保持连贯性。这样可以避免上下文过长导致 AI"记性不好"，同时让对话更有条理。

### 深度定制

基础功能用熟了之后，我开始琢磨怎么让 OpenCode 更符合我的工作流。以下是我实践下来觉得很有用的定制技巧。

**自定义命令：把重复的工作流打包**

我经常需要给新项目生成 README 文档，每次都要写一堆提示词。后来我干脆把这个流程封装成一个自定义命令：

```bash
mkdir -p ~/.config/opencode/commands
cat > ~/.config/opencode/commands/project-analysis.md << 'EOF'
---
agent: build
description: 全面分析当前工程，提供项目改进建议
---
## 你的任务

全面分析项目结构，理解其类型和核心价值，创建专业的 `README.md`文件。如果文档已存在，则智能补充更新。

## 执行流程

### 1. 扫描项目结构

使用 `Glob` 扫描：

- 根目录文件（配置、入口文件）
- 子目录结构
...
EOF
```

重启 OpenCode 后，直接输入 `/project-analysis`，它就会自动分析项目并生成文档。相当于我自己造了一个"快捷指令"，把那些经常重复的工作流都打包起来，省时省力。

**配置 MCP 服务器：给 AI 扩展"超能力"**

MCP（Model Context Protocol）是个好东西，相当于给 AI 装插件。比如我想让 AI 能直接查询数据库：

在 `opencode.json` 中添加：

```json
{
  "mcpServers": {
    "database": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres"],
      "env": {
        "DATABASE_URL": "postgresql://..."
      }
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "your_github_token"
      }
    }
  }
}
```

配置完后，我可以让 AI 直接查询数据库里的表结构，或者帮我创建 GitHub Issue。相当于把 AI 和公司现有的工具链打通了，不再局限于代码编辑器里。

**权限精细控制：该放手时就放手**

刚开始用的时候，我设置了所有操作都要询问权限，这样比较安全。但用久了发现，有些操作完全可以自动执行。

编辑 `opencode.json`，给不同的工具设置不同的权限：

```json
{
  "tools": {
    "bash": {
      "permission": "ask"  // 执行命令前要问我
    },
    "write": {
      "permission": "ask"  // 创建文件前要问我
    },
    "edit": {
      "permission": "allow",  // 修改文件不用问
      "patterns": ["src/**/*.js"]  // 但只允许改 src 目录下的 js 文件
    }
  }
}
```

这样 AI 在 src 目录改代码时不用频繁问我，但执行命令或创建新文件时还是会确认，平衡了效率和安全。你可以根据信任程度和工作习惯，灵活控制 AI 的权限。

**使用 oh-my-opencode 扩展：多智能体协作的黑科技**

oh-my-opencode 是社区开发的多智能体协作框架，里面有 Sisyphus、Hephaestus 等多个专业 Agent，能自动协调完成复杂任务。

说实话，刚开始我觉得这玩意儿有点"高大上"，但实际用下来确实挺香。比如我说：

```
ultrawork: 实现一个支持暗黑模式的 React 组件
```

它会自动拆解任务，有的 Agent 负责写组件逻辑，有的负责处理样式切换，有的负责测试，协同工作。

> ⚠️ **安全提醒**：这个项目是免费开源的，GitHub 上能找到。千万别信那些让你付费的网站，都是骗子。

安装的话，最简单的方式是让 AI 帮你自动配置：

```
请帮我安装和配置 oh-my-opencode，按照以下指南操作：
https://raw.githubusercontent.com/code-yeongyu/oh-my-opencode/refs/heads/master/docs/guide/installation.md
```

遇到特别复杂的任务，一个 AI 搞不定的时候，多个 Agent 协作会更高效。

**非交互模式脚本化：让 AI 在后台默默干活**

有时候我需要批量处理一些任务，比如检查多个项目的代码质量。这时候可以用非交互模式：

```bash
# 单次任务
opencode -p "生成项目 README"

# 指定目录
opencode -c ~/my-project -p "修复 lint 错误"

# JSON 输出，方便后续处理
opencode -p "检查代码质量" -f json
```

这个在 CI/CD 流程里特别有用。比如每次提交代码后，自动运行代码检查，发现问题直接报出来。在自动化场景里，不需要人工交互，AI 自己就能干活。


**导出对话：好记性不如烂笔头**

```
/export   # 导出为 Markdown
```

有时候和 AI 的对话里会有一些有价值的思路或方案，我会导出保存下来，以后遇到类似问题可以参考。这样可以保存有价值的对话内容，便于整理和分享。

**多会话并行：一心可以二用**

同时开多个 OpenCode 实例，一个窗口处理前端任务，另一个处理后端任务，互不干扰。这在需要同时跟进多个需求的时候特别有用，能让工作区保持整洁和专注。

**IDE 集成：在熟悉的环境里用 AI**

VS Code 有 OpenCode 的扩展，装上后可以在编辑器里直接调用 AI。这样不用在终端和编辑器之间来回切换，体验更流畅。如果你习惯了 VS Code 的工作流，集成插件能让你无缝衔接。

## 实战案例

### 案例 1：快速创建 Node.js API

**步骤**：

1.创建目录：

   ```bash
   mkdir my-api && cd my-api
   npm init -y
   ```

2.启动 OpenCode：

   ```bash
   opencode
   ```

3.初始化项目：

   ```
   /init
   ```

4.描述需求：

   ```
   创建一个 FastAPI 的 Web Service：
   - GET /contacts 路由返回Contact联系人的JSON格式
   - 添加错误处理中间件
   - 包含 README 使用说明
   ```

5.AI 自动生成代码和文档

### 案例 2：代码重构

**场景**：将回调函数重构为 async/await

```
将 @src/utils.js 中的所有回调函数改为 async/await 风格
```

AI 会：
- 分析文件
- 展示修改计划
- 执行重构
- 验证语法正确性

### 案例 3：Bug 修复流程

**步骤**：

1.描述问题：

```
用户反馈登录接口偶尔返回 500 错误，请定位并修复
```

2.AI 分析相关文件
3.提出修复方案
4.执行修复并测试

## GitHub Actions 集成

OpenCode 可以直接集成到 GitHub Actions 中，在 PR 和 Issue 中使用 `/opencode` 或 `/oc` 命令触发 AI 自动完成任务。

### 主要功能

- **自动修复 Issue**：在 Issue 中评论 `/opencode fix this`，自动创建分支、修复问题并提交 PR
- **PR 代码审查**：在 PR 中评论，自动审查代码或执行修改
- **定时任务**：通过 cron 定时运行 OpenCode 执行自动化任务
- **代码行级评论**：在 PR 的具体代码行上评论，OpenCode 会理解上下文并响应

### 安装配置

在项目中运行（确保已在 GitHub 仓库目录下）：

```bash
opencode github install
```

这会引导你完成：
1. 安装 OpenCode GitHub App
2. 创建 workflow 文件
3. 配置 API Key

### 使用示例

**自动修复 Bug**：
```
在 GitHub Issue 中评论：
/opencode 这个登录接口偶尔返回 500 错误，请定位并修复
```

**PR 代码修改**：
```
在 PR 中评论：
/opencode 在删除用户时添加软删除逻辑
```

**定时代码审查**：
```yaml
# .github/workflows/opencode-scheduled.yml
name: Weekly Code Review
on:
  schedule:
    - cron: "0 9 * * 1"  # 每周一上午 9 点
jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
      pull-requests: write
      issues: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 1
          persist-credentials: false
      - uses: anomalyco/opencode/github@latest
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        with:
          model: anthropic/claude-sonnet-4-20250514
          prompt: |
            审查本周的代码变更，找出潜在问题并提供建议
```

## 参考链接

- **官网**：[https://opencode.ai](https://opencode.ai)
- **GitHub**：[https://github.com/anomalyco/opencode](https://github.com/anomalyco/opencode)
- **文档**：[https://opencode.ai/docs](https://opencode.ai/docs)
- **Discord 社区**：[https://opencode.ai/discord](https://opencode.ai/discord)
