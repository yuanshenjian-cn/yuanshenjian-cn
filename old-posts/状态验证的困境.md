清扬采用跨进程的状态验证避开了 [行为验证的陷阱](https://www.yuque.com/yuanshenjian/agile/testing.behavior-verification-trap)，但有一些跨进程状态无法获取时，这种状态验证有点力不从心了。袁帅调整了`CIMonitor`的通知方式来探讨状态验证的困境。



下班后，他快速修改了`CIMonitor`，示意清扬过来讨论。功能是：构建失败后给提交人发邮件，类图如下：

![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/104324/1666773374388-e670c284-cc29-48be-8da3-1aee0ff48f41.jpeg)



在此场景中，`CIMonitor`会调用`EmailPublisher`，`EmailPublisher`会调用进程边界交互组件`JavaMailSender`（Spring mail提供的类库）来发送邮件到邮件服务器，邮件服务器会给指定邮箱的人发通知邮件。程序正常执行后的最终状态是：提交人收到的通知邮件。



在测试中，要获得最终数据状态，需要搭建一个可以发邮件的服务器，在测试执行后去验证指定邮箱的提交人是否收到邮件通知。

![画板](https://cdn.nlark.com/yuque/0/2023/jpeg/104324/1673225176000-7abd0d84-63fc-4784-810e-70a6022dd809.jpeg)



基于这种验证方式，测试时需要安装一个Fake Mail Server，该 Server 具备实际可用发送邮件的功能，且保存了成功发送出去的邮件记录，通过接口可以获得已成功发送邮件的邮件信息，即便如此，也是退而求其次的选择，因为几乎无法从接收者那里获得接收到的邮件信息。



袁帅给清扬演示完这个过程，她满脸质疑：“谁做测试会真这么做呀，搭建一个真正能够发邮件的服务器，成本有点高啊。再说了，在开发阶段做测试，这种跟第三方邮件服务器交互，不需要证明它发邮件的功能是否工作，**只需要证明的系统能把邮件发送到邮件服务器上就足够了吧**。”



“那怎么做呢？”



清扬接过键盘，花了不到十分钟的时间，写了一个基于JavaEmailServer的测试：

```java
class CIMonitorTest {
    private static GreenMail mailServer;
    private static JavaMailSenderImpl mailSender;

    @BeforeAll
    static void setup() {
        String HOST = "127.0.0.1";
        String USER = "root";
        String PASSWORD = "pass";
        int PORT = 9999;

        ServerSetup config = new ServerSetup(PORT, HOST, "smtp");
        mailServer = new GreenMail(config);
        mailServer.setUser("ci@thoughtworks.com", USER, PASSWORD);
        mailServer.start();

        mailSender = new JavaMailSenderImpl();
        mailSender.setHost(HOST);
        mailSender.setPort(PORT);
        mailSender.setUsername(USER);
        mailSender.setPassword(PASSWORD);
    }

    @Test
    void should_publish_notification_with_mock_behavior_verification() throws Exception {
        // Setup
        CIMonitor ciMonitor = new CIMonitor(new EmailPublisher(mailSender));

        // Exercise
        ciMonitor.buildFailed("sjyuan@thoughtworks.com", CIMonitor.Stage.TEST);

        // Verify
        MimeMessage receivedMessage = mailServer.getReceivedMessages()[0];
        assertEquals("[CI] Build WARNING!", receivedMessage.getSubject());
        String expectedContent = String.format("You break ci @ %s !!!", CIMonitor.Stage.TEST);
        assertEquals(expectedContent, receivedMessage.getContent());
    }
    
    @AfterAll
    static void teardown() {
        mailServer.stop();
    }
}
```

<font style="color:rgb(38, 38, 38);"></font>

<font style="color:rgb(38, 38, 38);">“你咋这么6，又生写了一个！” 袁帅表示称赞。</font>

<font style="color:rgb(38, 38, 38);"></font>

<font style="color:rgb(38, 38, 38);">“在测试初始化阶段，我安装了一个轻量的JavaEmailServer，使用</font>`mailServer.getReceivedMessages()`<font style="color:rgb(38, 38, 38);">获得服务器接收到的邮件信息，来验证要发送的邮件成功传送到邮件服务器上，至于能不能发送给用户，这不是我关心的事儿。” 清扬流畅地讲解自己的逻辑。</font>

<font style="color:rgb(38, 38, 38);"></font>

![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/104324/1666947176900-7e8fff6d-1790-4af6-bfd6-93dcf4c007ef.jpeg)



“真漂亮啊，用了「**跨进程行为验证**」，你搭建了一个轻量的 Spy Server，该 Spy Server 会记录系统发送的邮件信息，为后续验证提供查询接口。测试能够提供跟第三方邮件服务成功交互的信心。” 袁帅略带钦佩地总结着。



“咦，验证看起来是获取数据状态做验证呀，你怎么把它叫「行为验证」，还加了个跨进程限定。” 清扬有点不解的问道。



“哦，这样子，在我看来，状态验证的状态指的是程序执行的最终状态，这里你**使用了一个 Spy Server 来捕捉系统跟第三方系统调用所传递的数据，Spy Server 记录数据也只能证明你按照预期调用了第三方系统**，由于跨进程，所以我把它叫做「**跨进程行为验证**」” 袁帅回答时语速放慢了很多。



---

**小微小结**

+ 进程边界的「行为验证」的陷阱是无法验证进程间的协议以及映射的有效性，借助跨进程的「状态验证」可以解决，比如读写数据库时，代码和数据库表的映射，数据库交互协议。
+ 「跨进程状态验证」的困境是不能低成本地获得最终数据状态，可以借助「跨进程行为验证」，确保系统能够按照预期调用第三方系统。





