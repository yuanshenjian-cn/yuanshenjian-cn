“一会跳完了来我这哈，上次说就这代码聊聊 **「状态验证」 **和 **「行为验证」 **的。” 周五下午没啥急事，袁帅加大嗓门示意正在跳健身操的清扬。趁着这十分钟功夫，袁帅打开电脑准备了一些代码例子。

# 进程内验证

“小鬼，咱们先看个超级简单的，你看下面这两段代码在做什么验证？”袁帅说完等她给出答案。

```java
class ShoppingCartTest {
    @Test
    void should_add_item_to_shopping_cart_with_state_verification() {
        // Setup
        ShoppingCart shoppingcart = new ShoppingCart();
        Item iphone14 = new Item("iPhone 13", 5999);
        Item mi12 = new Item("XiaoMi 12", 4999);

        // Exercise
        shoppingcart.addItem(iphone14).addItem(iphone14).addItem(mi12);

        // Verify
        assertThat(shoppingcart.count(iphone14)).isEqualTo(2);
        assertThat(shoppingcart.count(mi12)).isEqualTo(1);
    }
}
```

“购物车添加了3件商品，然后验证购物车里面的商品是否符合预期，典型的「**状态验证**」”清扬火眼金睛。

“不错，继续！待测试场景：GraduateParkingBoy停车成功，车停到停车场....”袁帅还没讲完，清扬就打断：“咳，这个我知道，不用介绍太多，这个需求我太熟悉了，就单刀直入吧。”

![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/104324/1666771896940-28d1d90b-1a15-4947-b3ba-05d9fbfc320a.jpeg)

```java
class GraduateParkingBoyTest {
    @Test
    void should_park_to_first_parking_lot_with_state_verification() {
        // Setup
        ParkingLot parkingLot = new ParkingLot(1);
        GraduateParkingBoy parkingBoy = new GraduateParkingBoy(Arrays.asList(parkingLot));
        Car car = new Car("陕A YS6666");

        // Exercise
        Ticket ticket = parkingBoy.park(car);

        // Verify
        assertSame(car, parkingLot.pick(ticket));
    }
}
```

“这个也是**「状态验证」**，GraduateParkingBoy停车，验证最终车有没有停到预期的停车场。略微不同的是，GraduateParkingBoy会委托ParkingLot去停车，状态保存在ParkingLot对象里，该测试相当于把GraduateParkingBoy跟ParkingLot整体看做测试目标。”

“反应挺快呀，GraduateParkingBoy依赖了ParkingLot，在测试GraduateParkingBoy的时候，还有一种方式做测试，来看！”说完袁帅切切跳到下一个方法。

```java
@Test
void should_park_to_first_parking_lot_with_behavior_verification() {
    // Setup
    ParkingLot parkingLotMock = mock(ParkingLot.class);
    Car car = new Car("陕A YS6666");
    Ticket ticket = new Ticket("陕A YS6666");

    when(parkingLotMock.park(car)).thenReturn(ticket);

    // Exercise
    GraduateParkingBoy parkingBoy = new GraduateParkingBoy(Arrays.asList(parkingLotMock));
    Ticket ticketBoy = parkingBoy.park(car);

    // Verify
    assertSame(ticketBoy, ticket);
    verify(parkingLotMock, times(1)).park(car);
}
```

“嗯，这个是在验证 GraduateParkingBoy 跟 ParkingLot 的交互行为有没有按照预期发生，是 **「行为验证」 。**前提是ParkingLot的停车功能是好的，在此前提下，GraduateParkingBoy能正常调用它，就可相信GraduateParkingBoy该场景下停车功能是OK的。” 清扬利索回答道。

“很好，这个测试借助测试框架Mockito来配置一个Mock Object，当然还有其他方式做 **「行为验证」。**”袁帅见清扬突然很感兴趣想打断，立即抢先：“后面聊测试替身的时候咱们再一起探索其他做「**行为验证**」的方式。”

![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/104324/1667209966533-7fb241ea-6193-46a3-b673-28e5f34c98bb.jpeg)

# 触及进程边界

“够简单对吧，整一个稍微复杂的场景，给你加点难度，我把写好的测试代码特意删除了，你来用两种方式实现一下。” 袁帅边说边打开了类图：

![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/104324/1666773727806-1ad27bbe-ff66-4cc0-89a8-2fc669a9c371.jpeg)

“要测试一个CIMonitor的构建失败方法，当构建失败时，会调用CIFailedLogService将日志写到数据库中，这里面涉及到跨进程协作，进程边界的 `JdbcTemplate`组件会负责跟数据库进程通信。”

清扬迅速阅读了代码：

```java
public class CIMonitor {
    private final Map<Long, Stage> failedRecords = new HashMap<>();
    private final CIFailedLogService failedLogService;

    public CIMonitor(CIFailedLogService failedLogService) {
        this.failedLogService = failedLogService;
    }

    public void buildFailed(String spoilerEmail, Stage stage) {
        failedRecords.put(System.currentTimeMillis(), stage);
        failedLogService.log(spoilerEmail, stage);
    }

    public enum Stage {
        CHECKOUT, SPOT_BUG, TEST, DEPLOY
    }
}

public interface CIFailedLogService {
    boolean log(String spoilerEmail, CIMonitor.Stage stage);
}

public class CIFailedLogServiceJdbcImpl implements CIFailedLogService {
    private JdbcTemplate jdbcTemplate;
  
    public CIFailedLogServiceJdbcImpl(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public boolean log(String spoilerEmail, CIMonitor.Stage stage) {
        String sql = "insert into t_ci_failed_log(spoilerEmail, stage) values(?, ?)";
        int updateRow = jdbcTemplate.update(sql, UUID.randomUUID(), spoilerEmail, stage);
        return updateRow == 1;
    }
}
```

看完实现代码，她抢过来键盘开始流利的手法：

```java
@Test
void should_log_with_mock_behavior_verification() {
    // Setup
    JdbcTemplate jdbcTemplateMock = mock(JdbcTemplate.class);
    String sql = "insert into t_ci_failed_log(spoilerEmail, stage) values(?, ?)";

    // Exercise
    new CIMonitor(new CIFailedLogJdbcImpl(jdbcTemplateMock))
            .buildFailed("sjyuan@thoughtworks.com", CIMonitor.Stage.TEST);

    // Verify
    verify(jdbcTemplateMock, times(1))
            .update(sql, "sjyuan@thoughtworks.com", CIMonitor.Stage.TEST);
}
```

袁帅看出来清扬试图将 `CIMonitor`和 `CIFailedLogServiceJdbcImpl`俩当做一个黑盒来测试，使用测试替身 `jdbcTemplateMock`代替 `JdbcTemplate`，注入到 `CIFailedLogServiceJdbcImpl`，然后验证 `jdbcTemplateMock`是否按照预期执行了SQL语句，典型的 「**行为验证**」，测试类图如下：

![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/104324/1666772995813-d0492a51-ef4f-4a5e-8db7-205b1dc991cc.jpeg)

“所以，你认为 `jdbcTemplateMock`执行了这个SQL语句（**因：更新操作**），就能推断出会将这条记录保存到数据库中咯（**果：表记录**）？”袁帅问道。

“呜...嗯，呜...嗯，呜...嗯...”   清扬刚准备回答，消防警报声（演习）响起来了，两人稍作整顿开始往楼梯通道走去。

---

**小微小结**

+ 当状态在同一个进程内可便捷访问时，通过最终状态进行验证，这种 **状态验证** 是一种常用的方式。
+ 进程内 **「行为验证」** 可以提供更细粒度的等效验证，细粒度的测试帮助定位问题。由于是交互过程的验证，会增加测试的脆弱性。

**小微思考**

+ 当行为验证处在进程边界，正确调用了负责通信类库组件，就能证明跨进程的交互正确么？
