上周五，清扬和袁帅在探讨 [进程内测试验证](https://www.yuque.com/yuanshenjian/agile/testing.verification-in-process) 时，先是写了进程内行为验证和状态验证的测试，最后写了触及进程边界的行为验证，测试类图如下：



![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/104324/1666772989328-1f48c4a4-68a4-40a5-b67a-2b69632a77c7.jpeg)





周一清晨，一大早来到公司，清扬就把新的测试类图展示在屏幕上，等待袁帅的到来：

![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/104324/1666773132458-071300c0-340e-43df-a465-11e1dac5a189.jpeg)



“我回去想了想，`jdbcTemplateMock`按照预期执行update方法，没法证明就一定能保存到数据库中。因为，如果SQL语句哪个字段名或者表名写错了，或者语法存在错误，这个行为验证是是没办法发现的问题的，” 见袁帅到来，清扬轻快地说着自己的理解。



“嗯嗯，有道理，那你后来怎么做的？”袁帅丢下背包，随即问道。



清扬没有例会他的提问，继续按照自己的思路：“**在涉及到进程边界时，尤其要格外留意测试的有效性，不同进程之间往往存在一些通信协议，比如jdbc、http、socket，这时候某个进程内的行为验证是很难发现这种问题的**，**这是行为验证的一个陷阱**。此时需要一种等效的验证方式，它能够覆盖住跨进程的通信协议，最好还能表达最终的数据状态。” 



袁帅来到清扬的显示器前，快速浏览了新的测试类图后就示意她看代码。紧接着她把之前的 **行为验证 **和周末在家写的基于 In-Memory Database 的 **状态验证 **同时展示在屏幕上：

```java
@Test
void should_log_with_layer_cross_mock_behavior_verification() {
    // Setup
    JdbcTemplate jdbcTemplateMock = mock(JdbcTemplate.class);
    CIFailedLogServiceJdbcImpl logService = new CIFailedLogServiceJdbcImpl(jdbcTemplateMock);
    String spoilerEmail = "sjyuan@thoughtworks.com";
    String sql = "insert into t_ci_failed_log(spoilerEmail, stage) values(?, ?)";

    // Exercise
    new CIMonitor(logService).buildFailed(spoilerEmail, CIMonitor.Stage.TEST);

    // Verify
    verify(jdbcTemplateMock, times(1))
            .update(sql, spoilerEmail, CIMonitor.Stage.TEST.toString());
}
```



```java
@Test
void should_log_with_process_cross_state_verification() throws Exception {
    // Setup
    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource());
    createTable(jdbcTemplate.getDataSource());
    String spoilerEmail = "sjyuan@thoughtworks.com";

    // Exercise
    new CIMonitor(new CIFailedLogServiceJdbcImpl(jdbcTemplate))
            .buildFailed(spoilerEmail, CIMonitor.Stage.TEST);

    // Verify
    String querySql = "select spoilerEmail from t_ci_failed_log where id =?";
    String savedSpoilerEmail = jdbcTemplate.queryForObject(querySql, String.class, 1);
    assertThat(savedSpoilerEmail).isEqualTo(spoilerEmail);
}

private DataSource dataSource() throws Exception {
    Driver driver = (Driver) Class.forName("org.h2.Driver").getDeclaredConstructor().newInstance();
    SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
    dataSource.setDriver(driver);
    dataSource.setUrl("jdbc:h2:mem:testdb");
    dataSource.setUsername("root");
    dataSource.setPassword("pass");
    return dataSource;
}

private void createTable(DataSource dataSource) throws SQLException {
    Connection connection = dataSource.getConnection();
    String sql = """
            create table `t_ci_failed_log`
            (
                `id`           bigint       not null primary key auto_increment,
                `stage`        varchar(30)  not null,
                `spoilerEmail` varchar(100) not null
            );
            """;
    connection.createStatement().execute(sql);
    connection.commit();
    connection.close();
}
```



“将就看一下哈，在真实Spring boot项目中，我们只需要少量配置就可以完成JdbcTemplate的初始化。这个测试里，我验证行为最终写入数据库的数据状态是否符合预期。” 



“厉害厉害，竟然能生写出来。** In-Memory Database 是常见的**`**Fake Object**`**实践，我们认为它跟真实的生产数据库功能几乎一致，这么做能很好测试到程序真实运行时的功能，但也要注意一点是，有些数据库特定的语法可能会不支持导致测试不能完全等效。为了做得更好，现在一些项目会借助容器技术，在测试时快速启动一个跟生产环境一样的数据库，这样会提升测试的稳定性和信心。**” 袁帅从清扬的表情中清楚她已经Get到了这段话的意思。



“等等，这种场景下，数据状态是我们可控的数据库，那如果我是给第三方邮件系统发消息，邮件有没有成功发送给用户，这个状态我是获取不到的，怎么办呢？”袁帅刚要起身离开，清扬又抛出了一个灵魂拷问。



“好问题，那个我马上要参加一个会，晚点我们继续哈~” 袁帅抱起电脑径直走向Agile会议室。





---

**小微小结**

+ 涉及跨进程交互时，进程边界的行为验证存在陷阱，可引入跨进程的**状态验证来**规避此问题**。**
+ 常见的涉及跨进程的场景，跟内部数据库的交互，跟其他Web Service的交互。



**小微思考**

+ 当跨进程的状态无法获得时，跨进程的状态验证无法工作，有没有其他方式呢？



